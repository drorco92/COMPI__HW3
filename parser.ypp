%{
	#include "hw3_output.hpp"
	#include "Structs.hpp"
	#include "SymbolTables.hpp"
	using namespace output;

    extern int yylineno;
    extern char* yytext;
    int yyerror(const char * message);
    extern int yylex();
    void CheckLegalB(int n);
    Exp* NewCastedExp(const Exp& exp, const string& type);
    void validate_func(ArgVector expected, ArgVector current, string name);
    Function* get_func(string name, TypeList typelist);
    void vaildate_type(string x, string y);
    Exp* do_op(Exp* var1, Exp* var2, Operation op);
    string get_var_type(string var_name);
    void validate_assign(string var1, string var2);
    bool is_number(Exp* var);
    int yyerror(const char* message);
    int main();

    typedef enum {
        NONE,
        ASSIGN,
        RELOP,
        AND,
        OR,
        NOT,
        BINOP,
    }Operation;

    String[7] OperationType = {
        "", // NONE
        "ASSIGN",
        "RELOP",
        "AND",
        "OR",
        "NOT",
        "BINOP",
    };

    class Parser {
    private:
        SymbolTable symbolTable;
        string ScopeReturnType = "";
        int loopCount = 0;
    public:

        Parser();

        void AssertReturn(string& retType){
            if (retType != ScopeReturnType)
            {
                errorMismatch(yylineno);
                exit(0);
            }
        }

        void EnterLoopScope(){
            loopCount++;
            symbolTable.ScopeOpen();

        }

        void ExitLoopScope(){
            loopCount--;
            symbolTable.ScopeClose();
        }

        void AssertContinueLegal(){
            if (loopCount <= 0){
                errorUnexpectedContinue(yylineno);
                exit(1);
            }
        }

        void AssertBreakLegal(){
            if (loopCount <= 0){
                errorUnexpectedBreak(yylineno);
                exit(1);
            }
        }

    };

	Parser parser;

%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token CONST
%token TRUE
%token FALSE
%token RETURN
%token IF
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token LBRACE
%token RBRACE
%token ID
%token NUM
%token STRING
%type<exp> NUM
%type<id> ID
%type<exp> Exp
%type<exp> Type
%type<exp> RetType
%type<exp> Call
%type<exp> TypeAnnotation
%type<argument> FormalDecl
%type<argument_list> FormalsList
%type<argument_list> Formals
%type<type_list> ExpList


%right ASSIGN
%left OR
%left AND
%left RELOP_EQUAL
%nonassoc RELOP
%left BINOP_ADD
%left BINOP_MULTIPLY
%right NOT
%nonassoc RPAREN
%nonassoc LPAREN
%nonassoc ELSE

%%
Program        : Funcs                                                        {
                                                                                  parser.symbolTable.CloseGlobal();
                                                                              }


Funcs          : FuncDecl Funcs                                               {
                                                                                  ytext.tostring == "" ? :yyerror(nullptr);
                                                                              }
               |                                                              {
                                                                                  /* No Action */
                                                                              }


FuncDecl       : RetType ID LPAREN Formals RPAREN                             {
                                                                                  parser.AddSymbol($2->name, $1->type, $4->arguments);
                                                                              }
                 LBRACE                                                       {
                                                                                  parser.symbolTable.OpenScope();
                                                                                  parser.ScopeReturnType = $1->type;
                                                                                  parser.symbolTable.AddArgsSymbols($4->arguments);
                                                                              }
                 Statements                                                   {
                                                                                  /* No Action */
                                                                              }
                 RBRACE                                                       {
                                                                                  parser.ScopeReturnType = "";
                                                                                  parser.symbolTable.CloseScope();
                                                                              }


RetType        : Type                                                         {
                                                                                  $$ = new Exp($1->type);
                                                                              }
               | VOID                                                         {
                                                                                  $$ = new Exp("VOID");
                                                                              }


Formals        : FormalsList                                                  {
                                                                                  $$->arguments = $1->arguments;
                                                                              }
               |                                                              {
                                                                                  $$ = new ArgumentList();
                                                                              }


FormalsList    : FormalDecl                                                   {
                                                                                  $$ = new ArgumentList();
                                                                                  $$->arguments.push_back($1->argument);
                                                                              }
               | FormalDecl COMMA FormalsList                                 {
                                                                                  $$ = new ArgumentList();
                                                                                  $$->arguments = $3->arguments;
                                                                                  $$->arguments.push_back($1->argument);
                                                                              }


FormalDecl     : TypeAnnotation Type ID                                       {
                                                                                  $$ = new Argument($1->annotation, $2->type, $3->name);
                                                                              }


Statements     : Statement                                                    {
                                                                                  /* No Action */
                                                                              }
               | Statements Statement                                         {
                                                                                  /* No Action */
                                                                              }


Statement      : LBRACE ScopeStart Statements RBRACE ScopeEnd                 {
                                                                                  /* No Action */
                                                                              }
               | TypeAnnotation Type ID SC                                    {
                                                                                 parser.symbolTable.AddSymbol($1->annotation, $2->type, $3->name);
                                                                              }
               | TypeAnnotation Type ID ASSIGN Exp SC                         {
                                                                                 validate_assign($2->type, $5->type);
                                                                                 parser.symbolTable.AddSymbol($1->annotation, $2->type, $3->name);
                                                                              }
               | ID ASSIGN Exp SC                                             {
                                                                                  validate_assign($1->type, $3->type);
                                                                              }
               | Call SC                                                      {
                                                                                  /* No Action */
                                                                              }
               | RETURN SC                                                    {
                                                                                  parser.AssertReturn("VOID");
                                                                              }
               | RETURN Exp SC                                                {
                                                                                  parser.AssertReturn($2->type);
                                                                              }
               | IF LPAREN Exp RPAREN ScopeStart Statement ScopeEnd           {
                                                                                  vaildate_type($3->type, "BOOL");
                                                                              }
               | IF LPAREN Exp RPAREN ScopeStart Statement ScopeEnd ELSE ScopeStart Statement ScopeEnd                           
									                                          {
                                                                                  vaildate_type($3->type, "BOOL"); // Delete
                                                                              }
               | WHILE LPAREN Exp RPAREN ScopeEnd                             {
                                                                                  vaildate_type($3->type, "BOOL");
                                                                                  parser.EnterLoopScope();
                                                                              }
                Statement
                ScopeEnd
               | BREAK SC                                                     {
                                                                                  parser.AssertBreakLegal();
                                                                              }
               | CONTINUE SC                                                  {
                                                                                  parser.AssertContinueLegal();
                                                                              }


Call           : ID LPAREN ExpList RPAREN                                     {
                                                                                  // TODO: Change
                                                                                  Function* f = get_func($1->name, $3->argument_types);
                                                                                  $$ = new Exp(f->returnType);
                                                                               }
               | ID LPAREN RPAREN                                             {
                                                                                  // TODO: Change
                                                                                  Function* f = get_func($1->m_name, StringVector());
                                                                                  $$ = new Exp(f->return_type);
                                                                              }


ExpList        : Exp                                                          {
                                                                                  /* No Action */
                                                                              }
               | Exp COMMA ExpList                                            {
                                                                                  /* No Action */
                                                                              }

                                                                               // TODO: check if this actually works
Type           : INT                                                          {
                                                                               $$ = new Exp("INT");
                                                                              }
               | BYTE                                                         {
                                                                               $$ = new Exp("BYTE");
                                                                              }
               | BOOL                                                         {
                                                                               $$ = new Exp("BOOL");
                                                                              }


TypeAnnotation : CONST                                                        {
                                                                                  $$ = new Exp("CONST");
                                                                              }
               |                                                              {
                                                                                  /* No Action */ //TODO: Check if need to add as ""
                                                                              }


Exp            : LPAREN Exp RPAREN                                            {
                                                                                  $$ = new Exp($2->m_type);
                                                                              }
               | Exp BINOP_ADD Exp                                            {
                                                                                  $$ = do_op($1, $3, BINOP);
                                                                              }
               | Exp BINOP_MULTIPLY Exp                                       {
                                                                                  $$ = do_op($1, $3, BINOP);
                                                                              }
               | ID                                                           {
                                                                                  $$ = new Exp(get_var_type($1->name));
                                                                                  $$->name = $1->name;
                                                                              }
               | Call                                                         {
                                                                                  $$ = new Exp($1->type);
                                                                              }
               | NUM                                                          {
                                                                                  $$ = new Exp("INT");
                                                                              }
               | NUM B                                                        {
                                                                                CheckLegalB(yylval.val))
                                                                                  $$ = new Exp("BYTE");
                                                                              }
               | STRING                                                       {
                                                                                  $$ = new Exp("STRING");
                                                                              }
               | TRUE                                                         {
                                                                                  $$ = new Exp("BOOL");
                                                                              }
               | FALSE                                                        {
                                                                                  $$ = new Exp("BOOL");
                                                                              }
               | NOT Exp                                                      {
                                                                                  $$ = do_op($2, $2, NOT);
                                                                              }
               | Exp AND Exp                                                  {
                                                                                  $$ = do_op($1, $3, AND);
                                                                              }
               | Exp OR Exp                                                   {
                                                                                  $$ = do_op($1, $3, OR);
                                                                              }
               | Exp RELOP_EQUAL Exp                                          {
                                                                                  $$ = do_op($1, $3, RELOP);
                                                                              }
               | Exp RELOP Exp                                                {
                                                                                  $$ = do_op($1, $3, RELOP);
                                                                              }
               | LPAREN Type RPAREN Exp                                       {
                                                                                  $$ = NewCastedExp($4, $2->Type);
                                                                              }
ScopeStart      :                                                             {
                                                                                  parser.symbolTable.OpenScope();
                                                                              }


ScopeEnd        :                                                             {
                                                                                  parser.symbolTable.CloseScope();
                                                                              }


%%

int main()
{
	return yyparse();
}

int yyerror(const char* message)
{
	errorSyn(yylineno);
	exit(1);
}

void CheckLegalB(int n)
{
    if (n > 255)
    {
        errorByteTooLarge(yylineno, to_string(yylval.val));
        exit(1);
    }
}

bool is_number(Exp* var) {
    if (var->type == "INT" || var->type == "BYTE")
        return true;
    else
        return false;
}

void validate_assign(string var1, string var2) {

    if(var1 == "VOID" || !(var1 == var2 || (var1 == "INT" && var2 == "BYTE"))) {
        errorMismatch(yylineno);
        exit(1);
    }
}

string get_var_type(string var_name) {
    Symbol* var = (Symbol *)symbolTable.search_symbol(var_name, false);
    if(var == nullptr) {
        errorUndef(yylineno, var_name);
        exit(1);
    }
    return var->type;
}

Exp* do_op(Exp* var1, Exp* var2, Operation op) {
    if(var1->type == "STRING" || var2->type == "STRING") {
        goto err;
    }
    switch(op){
        case(ASSIGN):
            validate_assign(var1->type, var2->type);
            return var1;

        case(RELOP):
            if (is_number(var1) && is_number(var2))
                return new Exp("BOOL");
            break;

         case(AND): case(POR):
            if (var1->type == "BOOL" && var2->type == "BOOL")
                return new Exp("BOOL");
            break;

        case(NOT):
            if (var1->type == "BOOL")
                return new Exp("BOOL");
            break;

        case(BINOP):
            if (is_number(var1) && is_number(var2)){
                if(var1->type == "INT" || var2->type == "INT")
                    return new Exp("INT");
                else
                    return new Exp("BYTE");
            }
            break;
    }
err:
    errorMismatch(yylineno);
    exit(1);
}

void vaildate_type(string x, string y){
    if (x != y)
    {
        output::errorMismatch(yylineno);
        exit(0);
    }
}

Function* get_func(string name, TypeList typelist){
    Function* f = (FuncSymbol*)(symbolTable.GetSymbol(name, true));
    if (f == nullptr) {
        errorUndefFunc(yylineno, name);
        exit(0);
    }
    validate_func(f->args_type, typelist, f->name);
    return f;
}

void validate_func(ArgVector expected, ArgVector current, string name) {
    if (expected.size() != current.size())
    {
        errorPrototypeMismatch(yylineno, name, expected);
        exit(1);
    }
    int size = expected.size();
    for(int i=0; i < size; i++){
        if(expected[i] != current[size-i-1] && !(expected[i] == "INT" && current[size-i-1] == "BYTE")){
            errorPrototypeMismatch(yylineno, name, expected);
            exit(1);
        }
    }
}

Exp* NewCastedExp(const Exp& exp, const string& type) {
    string eType = exp->type;
    if((type == "BYTE" || type == "INT") && (eType == "BYTE" || eType == "INT")){
        return new Exp(type);
    }
    errorMismatch(yylineno);
    exit(1);
}
