%{
	#include "output.hpp"
	#include "Structs.hpp"
	using namespace output;

    enum {
        NONE,
        ASSIGN,
        RELOP,
        AND,
        OR,
        NOT,
        BINOP,
    };

    String[7] {
        "", // NONE
        "ASSIGN",
        "RELOP",
        "AND",
        "OR",
        "NOT",
        "BINOP",
    } ReturnType;

    class Parser {
    private:
        SymbolTable symbolTable;
        string curr_func_ret_type = "";
        int during_while = 0;
    public:
        Parser();
        Function* GetFunction(string name, std::vector<string> type_list){
            Function* f = static_cast<Fuction *>((parser.symbolTable.GetSymbol(name));
            if (f == nullptr) {
                errorUndefFunc(yylineno, name);
                exit(0);
            }
            validate_func(f->args_type, type_list, f->name);
            return f;
        }

    };
	Parser parser;
	extern int yylineno;
	int yyerror(const char * message);
    extern int yylex();
    void CheckLegalB(int n);
%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token CONST
%token TRUE
%token FALSE
%token RETURN
%token IF
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token LBRACE
%token RBRACE
%token ID
%token NUM
%token STRING
%type<exp> NUM
%type<id> ID
%type<exp> Exp
%type<exp> Type
%type<exp> RetType
%type<exp> Call
%type<argument> FormalDecl
%type<argument_list> FormalsList
%type<argument_list> Formals
%type<type_list> ExpList


%right ASSIGN
%left OR
%left AND
%left RELOP_EQUAL
%nonassoc RELOP
%left BINOP_ADD
%left BINOP_MULTIPLY
%right NOT
%nonassoc RPAREN
%nonassoc LPAREN
%nonassoc ELSE

%%
Program        : Funcs                                                        {parser.symbolTable.;}
Funcs          : FuncDecl Funcs                                               {if (yytext.tostring != "") yyerror(nullptr);}
               |                                                              {/* No Action */}
FuncDecl       : RetType ID LPAREN Formals RPAREN                             {Add func Symbols ID($2), Type($1)}
                 LBRACE                                                       { Open, set return type, set arguments}
                 Statements                                                   {/* No Action *}
                 RBRACE                                                       {Current ret type: ""(This is how we track which fumction we are in), Close Scope}
RetType        : Type                                                         {assert return type($1)}
               | VOID                                                         {assert return type($1)}
Formals        : FormalsList                                                  {$$->m_argsList = $1->m_argsList;}
               |                                                              {$$ = new FuncArgsList();}
FormalsList    : FormalDecl                                                   {
                                                                                $$ = new FuncArgsList();
                                                                                $$->m_argsList.push_back($1->m_arg);
                                                                              }
               | FormalDecl COMMA FormalsList                                 {
                                                                                  $$ = new FuncArgsList();
                                                                                  $$->m_argsList = $3->m_argsList;
                                                                                  $$->m_argsList.push_back($1->m_arg);
                                                                              }
FormalDecl     : TypeAnnotation Type ID                                       {new func arg: const, type ID}
Statements     : Statement                                                    {/* No Action */}
               | Statements Statement                                         {/* No Action */}
Statement      : LBRACE New_Scope Statements RBRACE End_Scope                 {/* No Action */}
               | TypeAnnotation Type ID SC                                    {Symbol Table add variable const, type, ID}
               | TypeAnnotation Type ID ASSIGN Exp SC                         {
                                                                                  Check if assignment is legal (need to know type for add var)
                                                                                  Try add var (if exists okay if Type TypeAnnot and Type == "")
                                                                              }
               | ID ASSIGN Exp SC                                             {validate assignment}
               | Call SC                                                      {/* No Action */}
               | RETURN SC                                                    {validate function return type is void}
               | RETURN Exp SC                                                {validate function return type is $2->type}
               | IF LPAREN Exp RPAREN New_Scope Statement End_Scope           {/* No Action */}
               | IF LPAREN Exp RPAREN New_Scope Statement End_Scope           {Validate $3->type boolean}
                ELSE New_Scope Statement End_Scope                            {Validate $3->type boolean}
               | WHILE LPAREN Exp RPAREN New_Scope                            {Validate $3->type boolean, nested_loop++} // Should I open scope? possibly
                Statement
                End_Scope
               | BREAK SC                                                     {if (!nested_loop) error(ILLEGALBREAK) exit(0);}
               | CONTINUE SC                                                  {if (!nested_loop) error(ILLEGALCONT) exit(0);}
Call           : ID LPAREN ExpList RPAREN                                     {??}
               | ID LPAREN RPAREN                                             {??}
ExpList        : Exp                                                          {/* No Action */}
               | Exp COMMA ExpList                                            {/* No Action */}
Type           : INT                                                          {$$ = new Exp($1);}
               | BYTE                                                         {$$ = new Exp($1);}
               | BOOL                                                         {$$ = new Exp($1);}
TypeAnnotation : CONST                                                        {$$ = new Exp($1);}
               |                                                              {/* No Action */}
Exp            : LPAREN Exp RPAREN                                            {$$ = new Exp($2->m_type);}
               | Exp BINOP_ADD Exp                                            {$$ = do_op($1, $3, PBINOP);}
               | Exp BINOP_MULTIPLY Exp                                       {$$ = do_op($1, $3, PBINOP);}
               | ID                                                           {
                                                                                 $$ = new Exp(type($1->name));
                                                                                 $$->m_varName = $1->m_name;
                                                                              }
               | Call                                                         {$$ = new Exp($1->m_type);}
               | NUM                                                          {$$ = new Exp("INT");}
               | NUM B                                                        {
                                                                                CheckLegalB(yylval.val))
                                                                                $$ = new Exp("BYTE");
                                                                              }
               | STRING                                                       {$$ = new Exp("STRING");}
               | TRUE                                                         {$$ = new Exp("BOOL");}
               | FALSE                                                        {$$ = new Exp("BOOL");}
               | NOT Exp                                                      {$$ = do_op($2, $2, PNOT);}
               | Exp AND Exp                                                  {$$ = do_op($1, $3, PAND);}
               | Exp OR Exp                                                   {$$ = do_op($1, $3, POR);}
               | Exp RELOP_EQUAL Exp                                          {$$ = do_op($1, $3, PRELOP);}
               | Exp RELOP Exp                                                {$$ = do_op($1, $3, PRELOP);}
               | LPAREN TYPE RPAREN EXP                                       {
                                                                                if cast_legal($2, $4->type);
                                                                                $$ = new CastedExp($4, $2);
                                                                              }
New_Scope      :                                                              {Close Scope;}
End_Scope      :                                                              {Open New Scope;}
%%

int main()
{
	return yyparse();
}

int yyerror(const char* message)
{
	errorSyn(yylineno);
	exit(1);
}

void CheckLegalB(int n)
{
    if (n > 255)
    {
        errorByteTooLarge(yylineno, to_string(yylval.val));
        exit(1);
    }
}